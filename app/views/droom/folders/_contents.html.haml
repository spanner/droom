- limit ||= false
- for_more ||= false
- flat ||= false
- narrow ||= false
- document_count = folder.documents.count
- drop_refreshes ||= "#folder_#{folder.id}"
- lidata = {}
- uldata = {}
- ulclass = ''
- if !flat && can?(:edit, folder)
  - lidata = {droppable: droom.folder_documents_path(folder), queue: "#queue_to_#{folder.id}", refreshes: drop_refreshes}
  - uldata = {folder_id: folder.id}
  - ulclass = 'sortable_files'

%ul.filing<
  - if limit && document_count > 0 && limit < document_count
    %li.files{data: lidata}
      %ul
        = render :partial => 'droom/documents/listing', :collection => folder.documents.limit(limit), locals: {narrow: narrow}
        - if for_more
          %li.more
            = link_to t(:more_documents_count, :count => document_count - limit), for_more

  - else
    - if document_count > 0
      %li.files{data: lidata}
        %ul{class: ulclass, data: uldata}
          = render :partial => 'droom/documents/listing', :collection => folder.documents, locals: {narrow: narrow}

    - children = folder.children
    - if flat # floated in event view
      - if for_more && children.any?
        %li.more
          = link_to t(:more_subfolders_count, :count => children.count), for_more

    - else
      %li.folders
        %ul
          - if limit && limit < document_count + folder.children.count
            - children = children.limit(limit - document_count)
            - children = children.populated unless can?(:edit, folder)
            = render :partial => 'droom/folders/folder', :collection => children, :locals => {:defer_contents => true}
            - if for_more
              %li.more
                = link_to t(:more), for_more
          - else
            = render :partial => 'droom/folders/folder', :collection => children, :locals => {:defer_contents => true}
